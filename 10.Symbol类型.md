# L-11 Symbol类型
## 概述
> 在ES5中的对象属性名都是字符串，这很容易造成属性名的冲突和覆盖。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。
> ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言继undefined、null、Boolean、String、Number和Object之后的第七种基本数据类型。
## 定义Symbol类型
| 语法 | 参数 |
| ---- | ---- |
| Symbol([description]) | description：可选参数，Symbol的描述，可用于调试但不能访问自身 |
* 可以直接使用Symbol()方法创建新的symbol类型数据，如下：
```js
let s = Symbol();
console.log(typeof s);          //symbol
console.log(s);                 //Symbol()
```
* 也可以向Symbol()方法中传入字符串作为描述符，如下：
```js
let s = Symbol('123');
console.log(typeof s);          //symbol
console.log(s);                 //Symbol(123)
```
* Symbol方法可接受其他6种基本数据类型参数作为描述符，如下：
```js
console.log(Symbol(123));
console.log(Symbol('123'));
console.log(Symbol(true));
console.log(Symbol(undefined));
console.log(Symbol(null));
console.log(Symbol({}));
```
![avatar](images/Symbol/1.png)
* 创建出来的symbol数据看似相同吗，但是实际上都是独立的一个新的symbol类型数据，如下：
```js
console.log(Symbol('123') === Symbol('123'));
console.log(Symbol(123) === Symbol(123));
console.log(Symbol(true) === Symbol(true));
console.log(Symbol(undefined) === **Symbol**(undefined));
console.log(Symbol(null) === Symbol(null));
console.log(Symbol({}) === Symbol({}));
```
![avatar](images/Symbol/2.png)
* 除了String类型的数据之外，当使用其他几种类型数据作为Symbol()方法的描述符时，会先调用其自身或原型上的toString()方法。将其转换为String类型，再作为Symbol()方法的描述符创建symbol数据。如下示例：
```js
var obj = {
    toString : function () {
        return 'abc';
    }
}
let s = Symbol(obj);
console.log(s);                 // Symbol(abc)
```
* 当使用symbol数据作为Symbol()方法的描述符时，会抛出TypeError。如下：
```js
console.log(Symbol(Symbol()));
```
![avatar](images/Symbol/3.png)
* symbol数据不能与其他类型的值进行运算，会报错。如下：
```js
let s = Symbol('abc');
"I am " + s;                // Uncaught TypeError: Cannot convert a Symbol value to a string
`I am ${s}`;                // Uncaught TypeError: Cannot convert a Symbol value to a string
```
* symbol数据可以显性转为String类型，如下：
```js
let s = Symbol('abc');
console.log(s);
console.log(s.toString(s));
console.log(String(s));
```
![avatar](images/Symbol/4.png)
* symbol数据也可以转化为Boolean类型，但是不能转化为Number类型。如下：
```js
let s = Symbol('abc');
console.log(Boolean(s));    // true
console.log(!s);            //false

console.log(Number(s));     // Uncaught TypeError: Cannot convert a Symbol value to a number
console.log(s + 2);         // Uncaught TypeError: Cannot convert a Symbol value to a number
```
## 不能使用new关键字创建symbol数据
> 在使用new关键字创建symbol数据时，会抛出错误，如下：
```js
let s = new Symbol();
```
![avatar](images/Symbol/5.png)
> 在JavaScript中，String、Number和Boolean这几种基本数据类型都可以通过new关键字创建，如下：
```js
console.log(new String('123'));
console.log(new Number(123));
console.log(new Boolean(1));
```
![avatar](images/Symbol/6.png)
### * 为何Symbol()不能使用new实例化？
> 因为这会创建一个**显式的Symbol包装器对象**，而不是一个`symbol`值。围绕原始数据类型创建显示包装器对象的做法，从ECMAScript2015开始就不再被支持。但是现有的原始包装器对象：如`new Number()`、`new String()`以及`new Boolean()`等都因为历史遗留问题仍可使用。
### * 创建Symbol包装器对象
> 如果仍想创建一个Symbol包装器对象，可以使用Object()方法创建。如下：
```js
let sym = Symbol();
console.log(sym);
var symObj = Object(sym);
console.log(symObj);
console.log(new Number('123'));
```
![avatar](images/Symbol/7.png)