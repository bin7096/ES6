# L-11 Symbol类型
## 概述
> 在ES5中的对象属性名都是字符串，这很容易造成**属性名的冲突和覆盖**。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入**Symbol**的原因。
> ES6引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是JavaScript语言继`undefined`、`null`、`Boolean`、`String`、`Number`和`Object`之后的**第七种基本数据类型**。
## 定义Symbol类型
| 语法 | 参数 |
| ---- | ---- |
| Symbol([description]) | description：可选参数，Symbol的描述，可用于调试但不能访问自身 |
* 可以直接使用`Symbol`方法创建新的`symbol`类型数据，如下：
```js
let s = Symbol();
console.log(typeof s);          //symbol
console.log(s);                 //Symbol()
```
* 也可以向`Symbol`方法中传入**String类型数据**作为描述符，如下：
```js
let s = Symbol('123');
console.log(typeof s);          //symbol
console.log(s);                 //Symbol(123)
```
* `Symbol`方法可接受其他**6种基本数据类型**参数作为描述符，如下：
```js
console.log(Symbol(123));
console.log(Symbol('123'));
console.log(Symbol(true));
console.log(Symbol(undefined));
console.log(Symbol(null));
console.log(Symbol({}));
```
![avatar](images/Symbol/1.png)
* 创建出来的`symbol`数据看似相同，但是实际上都是独立的一个**新的symbol类型数据**，如下：
```js
console.log(Symbol('123') === Symbol('123'));
console.log(Symbol(123) === Symbol(123));
console.log(Symbol(true) === Symbol(true));
console.log(Symbol(undefined) === Symbol(undefined));
console.log(Symbol(null) === Symbol(null));
console.log(Symbol({}) === Symbol({}));
```
![avatar](images/Symbol/2.png)
* 除了`String`类型的数据之外，当使用其他几种类型数据作为`Symbol`方法的描述符时，会先调用其自身或原型上的`toString`方法。将其转换为`String`类型，再作为`Symbol`方法的描述符创建`symbol`数据。如下示例：
```js
var obj = {
    toString : function () {
        return 'abc';
    }
}
let s = Symbol(obj);
console.log(s);                 // Symbol(abc)
```
* 当使用`symbol`数据作为`Symbol`方法的描述符时，会抛出`TypeError`。如下：
```js
console.log(Symbol(Symbol()));
```
![avatar](images/Symbol/3.png)
* `symbol`数据不能与其他类型的值进行运算，会报错。如下：
```js
let s = Symbol('abc');
"I am " + s;                // Uncaught TypeError: Cannot convert a Symbol value to a string
`I am ${s}`;                // Uncaught TypeError: Cannot convert a Symbol value to a string
```
* `symbol`数据可以显式转为`String`类型，如下：
```js
let s = Symbol('abc');
console.log(s);
console.log(s.toString(s));
console.log(String(s));
```
![avatar](images/Symbol/4.png)
* `symbol`数据也可以转化为`Boolean`类型，但是不能转化为`Number`类型。如下：
```js
let s = Symbol('abc');
console.log(Boolean(s));    // true
console.log(!s);            //false

console.log(Number(s));     // Uncaught TypeError: Cannot convert a Symbol value to a number
console.log(s + 2);         // Uncaught TypeError: Cannot convert a Symbol value to a number
```
## 不能使用new关键字创建symbol数据
> 在使用**new关键字**创建`symbol`数据时，会抛出错误，如下：
```js
let s = new Symbol();
```
![avatar](images/Symbol/5.png)
> 在JavaScript中，`String`、`Number`和`Boolean`这几种基本数据类型都可以通过**new关键字**创建，如下：
```js
console.log(new String('123'));
console.log(new Number(123));
console.log(new Boolean(1));
```
![avatar](images/Symbol/6.png)
### * 为何Symbol不能使用new关键字实例化？
> 因为这会创建一个**显式的Symbol包装器对象**，而不是一个`symbol`值。围绕原始数据类型创建显示包装器对象的做法，从`ECMAScript2015`开始就不再被支持。但是现有的原始包装器对象：如`new Number()`、`new String()`以及`new Boolean()`等都因为历史遗留问题仍可使用。
### * 创建Symbol包装器对象
> 如果仍想创建一个**Symbol包装器对象**，可以使用`Object`方法创建。如下：
```js
let sym = Symbol();
console.log(sym);
var symObj = Object(sym);
console.log(symObj);
console.log(new Number('123'));
```
![avatar](images/Symbol/7.png)
## Symbol属性名
> 由于每一个Symbol值都是不相等的，这意味着symbol数据可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
### * symbol数据作为对象属性名时，不能使用点运算符
> 因为点运算符后面跟着的是字符串，所以不会读取变量指向的那个symbol数据。导致属性名实际上是一个字符串，而不是一个symbol数据。如下：
```js
let sym = Symbol();
let obj = {};
obj.sym = 123;
console.log(obj[sym]);          // undefined
console.log(obj['sym']);        // 123
```
### * 通过Object.defineProperty方法定义
```js
let sym = Symbol();
let obj = {};
Object.defineProperty(obj, sym, {value : 'symbol'});
console.log(obj);
```
![avatar](images/Symbol/8.png)
### * 通过方括号定义对象的Symbol属性
> 在显式定义的对象中，定义Symbol属性必须使用方括号。如下：
```js
let sym = Symbol();
let obj1 = {};
obj1[sym] = 123;
let obj2 = {
    [sym] : 'abc'
};
console.log(obj1);
console.log(obj2);
```
![avatar](images/Symbol/9.png)
## Symbol属性
### * Symbol.prototype.description
> 返回symbol数据的描述符
```js
let sym = Symbol('abc');
console.log(sym.description);           // abc
```
### * Symbol.hasInstance
> 对象的Symbol.hasInstance属性，指向对象的一个内部方法。当其他对象使用instanceof运算符2时，会调用这个方法。如下：
```js
class Test {
    [Symbol.hasInstance](param){
        console.log(1);
        return false;
    }
};
console.log('abc' instanceof new Test());
var test = new Test();
console.log(typeof test[Symbol.hasInstance]);
```
![avatar](images/Symbol/10.png)
### * Symbol.isConcatSpreadable
> 对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于`Array.prototype.concat()`时，是否可以展开。
```js
// 数组进行concat合并时的默认行为是展开的，它的isConcatSpreadable默认为undefined。
let arr = [1, 2, 3];
console.log(arr[Symbol.isConcatSpreadable]);
console.log([4, 5].concat(arr));
console.log('------------------------------------');
// 当数组的Symbol.isConcatSpreadable属性被设置为false时，数组在进行concat合并时，则不展开。
arr[Symbol.isConcatSpreadable] = false;
console.log([4, 5].concat(arr));
console.log('------------------------------------');

// 而类似数组的对象则相反，默认不展开。
let obj = {length : 3, 0 : 'a', 1 : 'b', 2 : 'c'};
console.log(obj[Symbol.isConcatSpreadable]);
console.log([0, 1].concat(obj));
console.log('------------------------------------');
// 当对象的Symbol.isConcatSpreadable属性设置为true时，它在进行concat合并时，是可以展开的。
obj[Symbol.isConcatSpreadable] = true;
console.log([0, 1].concat(obj));
```
![avatar](images/Symbol/11.png)
> Symbol.isConcatSpreadable属性也可以定义在类里面：
```js
class A1 extends Array{
    constructor(args){
        super(args);
        // 定义在实例上
        this[Symbol.isConcatSpreadable] = true;
    }
}
class A2 extends Array{
    constructor(args){
        super(args);
    }
    // 定义在类本身
    get [Symbol.isConcatSpreadable]() {
        return false;
    }
}
let a1 = new A1();
a1[0] = 3;
a1[1] = 4;
let a2 = new A2();
a2[0] = 5;
a2[1] = 6;
console.log([1, 2].concat(a1).concat(a2));
```
![avatar](images/Symbol/12.png)
### * Symbol.species
> 对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。
```js
class MyArray extends Array {
}

const a = new MyArray(1, 2, 3);
const b = a.map(x => x);
const c = a.filter(x => x > 1);

b instanceof MyArray // true
c instanceof MyArray // true
// 上面代码中，子类MyArray继承了父类Array，a是MyArray的实例，b和c是a的衍生对象。
// 你可能会认为，b和c都是调用数组方法生成的，所以应该是数组（Array的实例），但实际上它们也是MyArray的实例。
```
> Symbol.species属性就是为了解决这个问题而提供的。现在，我们可以为MyArray设置Symbol.species属性。
```js
class MyArray extends Array {
    // Symbol.species属性的固定写法，必须使用static关键字和get取值器
    static get [Symbol.species]() {
        return Array;
    }
}
let arr = new MyArray(1, 2, 3);
let a = arr.map(x => x);
let b = arr.filter(x => x > 1);
console.log(a instanceof MyArray);      // false
console.log(a instanceof Array);        // true
console.log(b instanceof MyArray);      // false
console.log(b instanceof Array);        // true
```
> 对象中默认的Symbol.speicies属性等同于下面的写法
```js
class obj extends xxxxx{
    static get [Symbol.species](){
        return this;
    }
}
```
> Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。
### * 
### *
### *
### *
### *
### *
### *